/*
 * Note: this file originally auto-generated by mib2c
 * using mib2c.old-api.conf
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "powerEthernetMIB.h"
#include "data.h"
#include "pethNotifications.h"

/*
 * powerEthernetMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in theheader
 *   variable below.
 */

oid powerEthernetMIB_variables_oid[] = {1, 3, 6, 1, 2, 1, 105};

/*
 * variable4 powerEthernetMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the powerEthernetMIB mib section
 */

struct variable4 powerEthernetMIB_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define PETHPSEPORTGROUPINDEX 1
    {PETHPSEPORTGROUPINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 1}},
#define PETHPSEPORTINDEX 2
    {PETHPSEPORTINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 2}},
#define PETHPSEPORTADMINENABLE 3
    {PETHPSEPORTADMINENABLE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE, var_pethPsePortTable, 4, {1, 1, 1, 3}},
#define PETHPSEPORTPOWERPAIRSCONTROLABILITY 4
    {PETHPSEPORTPOWERPAIRSCONTROLABILITY, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 4}},
#define PETHPSEPORTPOWERPAIRS 5
    {PETHPSEPORTPOWERPAIRS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE, var_pethPsePortTable, 4, {1, 1, 1, 5}},
#define PETHPSEPORTDETECTIONSTATUS 6
    {PETHPSEPORTDETECTIONSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 6}},
#define PETHPSEPORTPOWERPRIORITY 7
    {PETHPSEPORTPOWERPRIORITY, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE, var_pethPsePortTable, 4, {1, 1, 1, 7}},
#define PETHPSEPORTMPSABSENTCOUNTER 8
    {PETHPSEPORTMPSABSENTCOUNTER, ASN_COUNTER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 8}},
#define PETHPSEPORTTYPE 9
    {PETHPSEPORTTYPE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE, var_pethPsePortTable, 4, {1, 1, 1, 9}},
#define PETHPSEPORTPOWERCLASSIFICATIONS 10
    {PETHPSEPORTPOWERCLASSIFICATIONS, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 10}},
#define PETHPSEPORTINVALIDSIGNATURECOUNTER 11
    {PETHPSEPORTINVALIDSIGNATURECOUNTER, ASN_COUNTER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 11}},
#define PETHPSEPORTPOWERDENIEDCOUNTER 12
    {PETHPSEPORTPOWERDENIEDCOUNTER, ASN_COUNTER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 12}},
#define PETHPSEPORTOVERLOADCOUNTER 13
    {PETHPSEPORTOVERLOADCOUNTER, ASN_COUNTER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 13}},
#define PETHPSEPORTSHORTCOUNTER 14
    {PETHPSEPORTSHORTCOUNTER, ASN_COUNTER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 14}},
#define PETHMAINPSEGROUPINDEX 1
    {PETHMAINPSEGROUPINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethMainPseTable, 5, {1, 3, 1, 1, 1}},
#define PETHMAINPSEPOWER 2
    {PETHMAINPSEPOWER, ASN_GAUGE, NETSNMP_OLDAPI_RONLY, var_pethMainPseTable, 5, {1, 3, 1, 1, 2}},
#define PETHMAINPSEOPERSTATUS 3
    {PETHMAINPSEOPERSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethMainPseTable, 5, {1, 3, 1, 1, 3}},
#define PETHMAINPSECONSUMPTIONPOWER 4
    {PETHMAINPSECONSUMPTIONPOWER, ASN_GAUGE, NETSNMP_OLDAPI_RONLY, var_pethMainPseTable, 5, {1, 3, 1, 1, 4}},
#define PETHMAINPSEUSAGETHRESHOLD 5
    {PETHMAINPSEUSAGETHRESHOLD, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE, var_pethMainPseTable, 5, {1, 3, 1, 1, 5}},
#define PETHNOTIFICATIONCONTROLGROUPINDEX 1
    {PETHNOTIFICATIONCONTROLGROUPINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethNotificationControlTable, 5, {1, 4, 1, 1, 1}},
#define PETHNOTIFICATIONCONTROLENABLE 2
    {PETHNOTIFICATIONCONTROLENABLE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE, var_pethNotificationControlTable, 5, {1, 4, 1, 1, 2}},
};
/*    (L = length of the oidsuffix) */

/** Initializes the powerEthernetMIB module */
void init_powerEthernetMIB(void)
{

    DEBUGMSGTL(("powerEthernetMIB", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("powerEthernetMIB", powerEthernetMIB_variables, variable4,
                 powerEthernetMIB_variables_oid);

    /* place any other initialization junk you need here */
}

/*
 * var_powerEthernetMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_powerEthernetMIB(struct variable *vp,
                     oid *name,
                     size_t *length,
                     int exact,
                     size_t *var_len,
                     WriteMethod **write_method)
{
    return NULL;
}

static int pseport_oid2index(struct variable *vp, oid *name, size_t *length, int *grpid, int *portid)
{
    *grpid = *portid = -1;

    // printf("length %d, namlen %d\n", *length, vp->namelen);
    if (*length <= vp->namelen)
    {
        return 1;
    }

    if (*length >= vp->namelen + 1)
    {
        *grpid = name[vp->namelen];
    }

    if (*length >= vp->namelen + 2)
    {
        *portid = name[vp->namelen + 1];
    }

    return 1;
}

static int pseport_index2oid(struct variable *vp, oid *name, size_t *length, int grpid, int portid)
{
    memcpy(name, vp->name, vp->namelen * sizeof(name[0]));
    name[vp->namelen] = grpid;
    name[vp->namelen + 1] = portid;
    *length = vp->namelen + 2;

    return 1;
}

static char *oid2str(oid *name, int length)
{
#define BUFNUM 4
#define BUFLEN 512
    static char buf[BUFNUM][BUFLEN];
    static int bufid = 0;
    char *p = buf[bufid];
    int offset = 0;

    for (int i = 0; i < length; i++)
    {
        offset += snprintf(p + offset, BUFLEN - offset, ".%ld", name[i]);
    }

    bufid = (bufid + 1) % BUFNUM;

    return p;
}

/*
 * var_pethPsePortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_powerEthernetMIB above.
 */
unsigned char *
var_pethPsePortTable(struct variable *vp,
                     oid *name,
                     size_t *length,
                     int exact,
                     size_t *var_len,
                     WriteMethod **write_method)
{
    /* variables we may use later */
    int grpid, portid;
    pseport_oid2index(vp, name, length, &grpid, &portid);
    // printf("vp->name %s, name %s, exact %d, magic %d\n", oid2str(vp->name, vp->namelen), oid2str(name, *length), exact, vp->magic);
    port_t *p = exact ? get_data(grpid, portid) : getn_data(grpid, portid);
    if (!p) {
        // printf("invalid index %d, %d\n", grpid, portid);
        return NULL;
    }
    if (!exact) pseport_index2oid(vp, name, length, p->grpid, p->portid);

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    // case PETHPSEPORTGROUPINDEX:
    //     *var_len = sizeof(p->grpid);
    //     return (u_char *)&p->grpid;
    // case PETHPSEPORTINDEX:
    //     *var_len = sizeof(p->portid);
    //     return (u_char *)&p->portid;
    case PETHPSEPORTADMINENABLE:
        *write_method = write_pethPsePortAdminEnable;
        *var_len = sizeof(p->admin_enable);
        return (u_char *)&p->admin_enable;
    case PETHPSEPORTTYPE:
        *write_method = write_pethPsePortType;
        *var_len = strlen(p->type);
        return (u_char *)p->type;
    default:
        *var_len = 0;
        // printf("unsupported magic %d\n", vp->magic);
        return NULL;
    }
    printf("should never reach here\n");
    return NULL;
}
/*
 * var_pethMainPseTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_powerEthernetMIB above.
 */
unsigned char *
var_pethMainPseTable(struct variable *vp,
                     oid *name,
                     size_t *length,
                     int exact,
                     size_t *var_len,
                     WriteMethod **write_method)
{
    return NULL;
}
/*
 * var_pethNotificationControlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_powerEthernetMIB above.
 */
unsigned char *
var_pethNotificationControlTable(struct variable *vp,
                                 oid *name,
                                 size_t *length,
                                 int exact,
                                 size_t *var_len,
                                 WriteMethod **write_method)
{
    return NULL;
}

int write_pethPsePortAdminEnable(int action,
                                 u_char *var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char *statP,
                                 oid *name,
                                 size_t name_len)
{
    if (action != COMMIT) {
        return SNMP_ERR_NOERROR;
    }
    long value;
    int grpid;
    int portid;
    port_t *p;

    grpid = name[name_len - 2];
    portid = name[name_len - 1];

    p = get_data(grpid, portid);
    if (!p) {
        printf("invalid index %d, %d\n", grpid, portid);
        return SNMP_NOSUCHINSTANCE;
    }
printf("%d %d\n", var_val_type, ASN_INTEGER);
    // printf("action %d, var_val_len %ld, var_val_type %d, name %s\n", action, var_val_len, var_val_type, oid2str(name, name_len));
    if (var_val_type != ASN_INTEGER) {
        return SNMP_ERR_WRONGTYPE;
    }
printf("222 \n");
    if (var_val_len != sizeof(long)) {
        return SNMP_ERR_WRONGLENGTH;
    }

    value = *(long *)var_val;
    printf("value %ld\n", value);
    if (value != 1 && value != 2) {
        return SNMP_ERR_BADVALUE;
    }
printf("111 %d\n", action);
    if (p->admin_enable == value) {
        printf("no change\n");
        return SNMP_ERR_NOERROR;    /* no change */
    }
    
    p->admin_enable = value;
    send_pethPsePortOnOffNotification_trap(p->grpid, p->portid, value == 1 ? 3 : 1);

    return SNMP_ERR_NOERROR;
}

int write_pethPsePortType(int action,
                          u_char *var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char *statP,
                          oid *name,
                          size_t name_len)
{
    int grpid;
    int portid;
    port_t *p;

    if (action != COMMIT) {
        return SNMP_ERR_NOERROR;
    }

    grpid = name[name_len - 2];
    portid = name[name_len - 1];

    p = get_data(grpid, portid);
    if (!p) {
        printf("invalid index %d, %d\n", grpid, portid);
        return SNMP_NOSUCHINSTANCE;
    }

    printf("action %d, var_val_len %ld, var_val_type %d, name %s\n", action, var_val_len, var_val_type, oid2str(name, name_len));
    if (var_val_type != ASN_OCTET_STR) {
        return SNMP_ERR_WRONGTYPE;
    }

    if (var_val_len >= sizeof(p->type)) {
        return SNMP_ERR_WRONGLENGTH;
    }

    snprintf(p->type, var_val_len + 1, "%s", var_val);

    return SNMP_ERR_NOERROR;
}