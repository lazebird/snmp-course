/*
 * Note: this file originally auto-generated by mib2c
 * using mib2c.old-api.conf
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "powerEthernetMIB.h"
#include "data.h"
#include "pethNotifications.h"

/*
 * powerEthernetMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid powerEthernetMIB_variables_oid[] = {1, 3, 6, 1, 2, 1, 105};

/*
 * variable powerEthernetMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the powerEthernetMIB mib section
 */

struct variable powerEthernetMIB_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define PETHPSEPORTGROUPINDEX 1
    {PETHPSEPORTGROUPINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 1}},
#define PETHPSEPORTINDEX 2
    {PETHPSEPORTINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 2}},
#define PETHPSEPORTADMINENABLE 3
    {PETHPSEPORTADMINENABLE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE, var_pethPsePortTable, 4, {1, 1, 1, 3}},
#define PETHPSEPORTPOWERPAIRSCONTROLABILITY 4
    {PETHPSEPORTPOWERPAIRSCONTROLABILITY, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 4}},
#define PETHPSEPORTPOWERPAIRS 5
    {PETHPSEPORTPOWERPAIRS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE, var_pethPsePortTable, 4, {1, 1, 1, 5}},
#define PETHPSEPORTDETECTIONSTATUS 6
    {PETHPSEPORTDETECTIONSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 6}},
#define PETHPSEPORTPOWERPRIORITY 7
    {PETHPSEPORTPOWERPRIORITY, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE, var_pethPsePortTable, 4, {1, 1, 1, 7}},
#define PETHPSEPORTMPSABSENTCOUNTER 8
    {PETHPSEPORTMPSABSENTCOUNTER, ASN_COUNTER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 8}},
#define PETHPSEPORTTYPE 9
    {PETHPSEPORTTYPE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE, var_pethPsePortTable, 4, {1, 1, 1, 9}},
#define PETHPSEPORTPOWERCLASSIFICATIONS 10
    {PETHPSEPORTPOWERCLASSIFICATIONS, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 10}},
#define PETHPSEPORTINVALIDSIGNATURECOUNTER 11
    {PETHPSEPORTINVALIDSIGNATURECOUNTER, ASN_COUNTER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 11}},
#define PETHPSEPORTPOWERDENIEDCOUNTER 12
    {PETHPSEPORTPOWERDENIEDCOUNTER, ASN_COUNTER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 12}},
#define PETHPSEPORTOVERLOADCOUNTER 13
    {PETHPSEPORTOVERLOADCOUNTER, ASN_COUNTER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 13}},
#define PETHPSEPORTSHORTCOUNTER 14
    {PETHPSEPORTSHORTCOUNTER, ASN_COUNTER, NETSNMP_OLDAPI_RONLY, var_pethPsePortTable, 4, {1, 1, 1, 14}},
#define PETHMAINPSEGROUPINDEX 1
    {PETHMAINPSEGROUPINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethMainPseTable, 5, {1, 3, 1, 1, 1}},
#define PETHMAINPSEPOWER 2
    {PETHMAINPSEPOWER, ASN_GAUGE, NETSNMP_OLDAPI_RONLY, var_pethMainPseTable, 5, {1, 3, 1, 1, 2}},
#define PETHMAINPSEOPERSTATUS 3
    {PETHMAINPSEOPERSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethMainPseTable, 5, {1, 3, 1, 1, 3}},
#define PETHMAINPSECONSUMPTIONPOWER 4
    {PETHMAINPSECONSUMPTIONPOWER, ASN_GAUGE, NETSNMP_OLDAPI_RONLY, var_pethMainPseTable, 5, {1, 3, 1, 1, 4}},
#define PETHMAINPSEUSAGETHRESHOLD 5
    {PETHMAINPSEUSAGETHRESHOLD, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE, var_pethMainPseTable, 5, {1, 3, 1, 1, 5}},
#define PETHNOTIFICATIONCONTROLGROUPINDEX 1
    {PETHNOTIFICATIONCONTROLGROUPINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY, var_pethNotificationControlTable, 5, {1, 4, 1, 1, 1}},
#define PETHNOTIFICATIONCONTROLENABLE 2
    {PETHNOTIFICATIONCONTROLENABLE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE, var_pethNotificationControlTable, 5, {1, 4, 1, 1, 2}},
};
/*    (L = length of the oidsuffix) */

/** Initializes the powerEthernetMIB module */
void init_powerEthernetMIB(void)
{
    DEBUGMSGTL(("powerEthernetMIB", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("powerEthernetMIB", powerEthernetMIB_variables, variable, powerEthernetMIB_variables_oid);

    /* place any other initialization junk you need here */
}

/*
 * var_powerEthernetMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *var_powerEthernetMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
{
    return NULL;
}

static int pseport_oid2index(struct variable *vp, oid *name, size_t *length, int *grpid, int *portid)
{
    *grpid = *portid = -1;
    if (*length <= vp->namelen) return 1;
    if (*length >= vp->namelen + 1) *grpid = name[vp->namelen];
    if (*length >= vp->namelen + 2) *portid = name[vp->namelen + 1];
    return 1;
}
static int pseport_index2oid(struct variable *vp, oid *name, size_t *length, int grpid, int portid)
{
    memcpy(name, vp->name, vp->namelen * sizeof(name[0]));
    name[vp->namelen] = grpid;
    name[vp->namelen + 1] = portid;
    *length = vp->namelen + 2;
    return 1;
}
static char *oid2str(oid *name, int length)
{
#define BUFNUM 4
#define BUFLEN 512
    static char buf[BUFNUM][BUFLEN];
    static int bufid = 0;
    char *p = buf[bufid];
    int offset = 0;
    for (int i = 0; i < length; i++) offset += snprintf(p + offset, BUFLEN - offset, ".%d", name[i]);
    bufid = (bufid + 1) % BUFNUM;
    return p;
}

/*
 * var_pethPsePortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_powerEthernetMIB above.
 */
unsigned char *var_pethPsePortTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
{
    int grpid, portid;
    port_t *p = NULL;
    printf("vp->name %s, name %s, exact %d, magic %d\n", oid2str(vp->name, vp->namelen), oid2str(name, *length), exact, vp->magic);
    pseport_oid2index(vp, name, length, &grpid, &portid);
    if (exact) {
        if (grpid || portid < 0 || portid > 1) {
            printf("invalid index %d, %d\n", grpid, portid);
            return NULL;
        }
        p = &tbl[portid];
    } else {
        if (grpid > 0 || portid > 0) {
            printf("invalid index %d, %d\n", grpid, portid);
            return NULL;
        }
        p = &tbl[portid + 1];
        pseport_index2oid(vp, name, length, 0, portid + 1);
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    // case PETHPSEPORTGROUPINDEX:
    //     *var_len = sizeof(p->grpid);
    //     return (u_char *)&p->grpid;
    // case PETHPSEPORTINDEX:
    //     *var_len = sizeof(p->portid);
    //     return (u_char *)&p->portid;
    case PETHPSEPORTADMINENABLE:
        *write_method = write_pethPsePortAdminEnable;
        *var_len = sizeof(p->admin_enable);
        return (u_char *)&p->admin_enable;
    case PETHPSEPORTTYPE:
        *write_method = write_pethPsePortType;
        *var_len = strlen(p->type);
        return (u_char *)p->type;
    default:
        *var_len = 0;
        printf("unsupported magic %d\n", vp->magic);
        return NULL;
    }
    printf("should never reach here\n");
    return NULL;
}
/*
 * var_pethMainPseTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_powerEthernetMIB above.
 */
unsigned char *var_pethMainPseTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
{
    return NULL;
}
/*
 * var_pethNotificationControlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_powerEthernetMIB above.
 */
unsigned char *var_pethNotificationControlTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
{
    return NULL;
}

int write_pethPsePortAdminEnable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
{
    if (action != COMMIT) return SNMP_ERR_NOERROR;
    long value;
    int grpid = name[name_len - 2];
    int portid = name[name_len - 1];
    port_t *p = &tbl[portid];

    printf("action %d, var_val_len %d, var_val_type %d, name %s\n", action, var_val_len, var_val_type, oid2str(name, name_len));
    if (var_val_type != ASN_INTEGER) return SNMP_ERR_WRONGTYPE;
    if (var_val_len != sizeof(long)) return SNMP_ERR_WRONGLENGTH;
    value = *(long *)var_val;
    if (value != 1 && value != 2) return SNMP_ERR_BADVALUE;
    p->admin_enable = value;
    send_pethPsePortOnOffNotification_trap(p->grpid, p->portid, value == 1 ? 3 : 1);
    return SNMP_ERR_NOERROR;
}

int write_pethPsePortType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
{
    if (action != COMMIT) return SNMP_ERR_NOERROR;
    int grpid = name[name_len - 2];
    int portid = name[name_len - 1];
    port_t *p = &tbl[portid];

    printf("action %d, var_val_len %d, var_val_type %d, name %s\n", action, var_val_len, var_val_type, oid2str(name, name_len));
    if (var_val_type != ASN_OCTET_STR) return SNMP_ERR_WRONGTYPE;
    if (var_val_len >= sizeof(p->type)) return SNMP_ERR_WRONGLENGTH;
    snprintf(p->type, var_val_len + 1, "%s", var_val);
    return SNMP_ERR_NOERROR;
}
